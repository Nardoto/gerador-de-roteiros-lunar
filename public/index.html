<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gerador de Roteiros</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            background: #ffffff;
            min-height: 100vh;
            padding: 20px;
            color: #000000;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: #ffffff;
            border: 1px solid #e0e0e0;
            border-radius: 8px;
            padding: 40px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.05);
        }

        h1 {
            text-align: center;
            color: #000000;
            margin-bottom: 30px;
            font-weight: 300;
            letter-spacing: -0.5px;
            font-size: 2rem;
        }

        .grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 30px;
            align-items: start;
        }

        .input-section, .output-section {
            background: #fafafa;
            padding: 24px;
            border: 1px solid #e0e0e0;
            border-radius: 6px;
            height: 100%;
            display: flex;
            flex-direction: column;
        }

        .output-section {
            max-height: calc(100vh - 120px);
        }

        h2 {
            font-size: 1rem;
            margin-bottom: 20px;
            color: #000000;
            font-weight: 500;
            text-transform: uppercase;
            letter-spacing: 1px;
            font-size: 0.75rem;
        }

        label {
            display: block;
            margin-bottom: 6px;
            font-weight: 400;
            color: #666666;
            font-size: 0.85rem;
        }

        input, textarea, select {
            width: 100%;
            padding: 10px 12px;
            margin-bottom: 16px;
            border: 1px solid #d0d0d0;
            border-radius: 6px;
            font-size: 0.9rem;
            font-family: inherit;
            background: #ffffff;
            transition: all 0.2s ease;
            box-shadow: 0 1px 2px rgba(0, 0, 0, 0.05);
        }

        input:hover, textarea:hover, select:hover {
            border-color: #999999;
        }

        input:focus, textarea:focus, select:focus {
            outline: none;
            border-color: #000000;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.1);
            transform: translateY(-1px);
        }

        textarea {
            resize: vertical;
            min-height: 80px;
        }

        .input-row {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 12px;
        }

        button {
            width: 100%;
            padding: 14px;
            background: linear-gradient(180deg, #000000 0%, #1a1a1a 100%);
            color: white;
            border: none;
            border-radius: 6px;
            font-size: 0.9rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
            letter-spacing: 0.5px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2), 0 1px 2px rgba(0, 0, 0, 0.1);
            position: relative;
            overflow: hidden;
        }

        button::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.1), transparent);
            transition: left 0.5s;
        }

        button:hover::before {
            left: 100%;
        }

        button:hover:not(:disabled) {
            background: linear-gradient(180deg, #1a1a1a 0%, #333333 100%);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3), 0 2px 4px rgba(0, 0, 0, 0.2);
            transform: translateY(-2px);
        }

        button:active:not(:disabled) {
            transform: translateY(0);
            box-shadow: 0 1px 2px rgba(0, 0, 0, 0.2);
        }

        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none !important;
        }

        .messages {
            flex: 1;
            overflow-y: auto;
            background: white;
            border: 1px solid #d0d0d0;
            border-radius: 6px;
            padding: 20px;
            box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.05);
            min-height: 400px;
        }

        .message {
            margin-bottom: 16px;
            padding: 16px;
            background: #f5f5f5;
            border-radius: 6px;
            border-left: 3px solid #000000;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.05);
            transition: all 0.2s ease;
        }

        .message:hover {
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.1);
            transform: translateX(2px);
        }

        .message.user {
            background: #fafafa;
            border-left-color: #666666;
        }

        .message.assistant {
            background: #f0f0f0;
            border-left-color: #000000;
        }

        .message.system {
            background: #fafafa;
            border-left-color: #999999;
        }

        .message.error {
            background: #f5f5f5;
            border-left-color: #000000;
            border-left-width: 3px;
        }

        .message-label {
            font-weight: 500;
            margin-bottom: 8px;
            color: #000000;
            font-size: 0.75rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .message-content {
            white-space: pre-wrap;
            font-size: 0.75rem;
            line-height: 1.4;
            color: #444;
            max-height: 200px;
            overflow-y: auto;
        }

        .message-stats {
            margin-top: 10px;
            padding: 8px 12px;
            background: #fafafa;
            border-radius: 0;
            font-size: 0.85rem;
            color: #666;
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
            border: 1px solid #e0e0e0;
        }

        .message-stats span {
            font-weight: 500;
        }

        .prompt-toggle {
            margin-top: 8px;
            padding: 6px 14px;
            background: #f0f0f0;
            color: #000000;
            border: 1px solid #d0d0d0;
            border-radius: 0;
            font-size: 0.75rem;
            cursor: pointer;
            transition: background 0.2s;
        }

        .prompt-toggle:hover {
            background: #e0e0e0;
        }

        .prompt-content {
            display: none;
            margin-top: 10px;
            padding: 16px;
            background: #fafafa;
            border-left: 2px solid #000000;
            border-radius: 0;
            font-size: 0.8rem;
            white-space: pre-wrap;
            color: #333;
            max-height: 300px;
            overflow-y: auto;
        }

        .prompt-content.visible {
            display: block;
        }

        .progress {
            margin-top: 15px;
            padding: 12px;
            background: #fafafa;
            border-radius: 6px;
            text-align: center;
            font-weight: 400;
            color: #000000;
            display: none;
            border: 1px solid #e0e0e0;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.05);
        }

        .downloads {
            margin-top: 20px;
            display: none;
        }

        .download-btn {
            margin-bottom: 8px;
            padding: 12px;
            background: #000000;
            color: white;
            border: none;
            border-radius: 0;
            cursor: pointer;
            display: block;
            width: 100%;
            text-align: left;
            font-weight: 600;
        }

        .download-btn:hover {
            background: #333333;
        }
    </style>
    <!-- JSZip para criar arquivos ZIP -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
</head>
<body>
    <div class="container">
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 40px; padding-bottom: 20px; border-bottom: 1px solid #e0e0e0;">
            <div>
                <h1 style="margin: 0; font-weight: 300; letter-spacing: -1px;">Script Generator</h1>
                <div style="font-size: 11px; color: #999999; margin-top: 4px; letter-spacing: 0.5px;">Desenvolvido por Nardoto ¬∑ v4.9.0</div>
                <div id="userName" style="font-size: 12px; color: #666666; margin-top: 4px; text-transform: uppercase; letter-spacing: 0.5px;"></div>
            </div>
            <button id="logoutBtn" style="padding: 8px 20px; background: #000000; color: white; border: none; cursor: pointer; font-weight: 400; font-size: 14px;">
                Exit
            </button>
        </div>

        <div class="grid">
            <!-- Inputs -->
            <div class="input-section">
                <h2>Configuration</h2>

                <label>T√≠tulo do V√≠deo:</label>
                <input type="text" id="title" placeholder="Ex: A Vida de Mois√©s">

                <label>Tipo de Conte√∫do:</label>
                <select id="contentType">
                    <option value="historia">Hist√≥ria B√≠blica de Personagem</option>
                    <option value="curiosidade">Curiosidade B√≠blica</option>
                    <option value="estudo">Estudo Teol√≥gico</option>
                </select>

                <label>Tom e Contexto do Roteiro:</label>
                <textarea id="synopsis" placeholder="Descreva o tom e contexto do v√≠deo..."></textarea>

                <!-- Campo condicional para Estudo Teol√≥gico -->
                <div id="extraContentField" style="display: none;">
                    <label>Conte√∫do Extra (para Estudo Teol√≥gico):</label>
                    <textarea id="extraContent" placeholder="Informa√ß√µes adicionais para o estudo teol√≥gico..."></textarea>
                </div>

                <label>Idioma do Roteiro:</label>
                <select id="language">
                    <option value="pt">Portugu√™s</option>
                    <option value="en" selected>English</option>
                    <option value="es">Espa√±ol</option>
                </select>

                <div class="input-row">
                    <div>
                        <label>T√≥picos:</label>
                        <input type="number" id="numTopics" value="3" min="1" max="10">
                    </div>
                    <div>
                        <label>Subt√≥picos:</label>
                        <input type="number" id="numSubtopics" value="8" min="1" max="20">
                    </div>
                    <div>
                        <label>Caracteres Hook:</label>
                        <input type="number" id="hookChars" value="1000" step="100">
                    </div>
                </div>

                <label>Caracteres Totais:</label>
                <input type="number" id="totalChars" value="30000" step="1000">

                <label>Modelo Claude (para roteiro):</label>
                <select id="claudeModel">
                    <option value="claude-sonnet-4-5-20250929">Claude Sonnet 4.5</option>
                    <option value="claude-sonnet-4-20250514">Claude Sonnet 4</option>
                    <option value="claude-opus-4-1-20250805" selected>Claude Opus 4.1 (Recomendado)</option>
                    <option value="claude-haiku-4-5">Claude Haiku 4.5 (Mais R√°pido)</option>
                </select>

                <!-- Configura√ß√£o de Blocos -->
                <div style="background: #fafafa; padding: 12px; border-radius: 0; margin-bottom: 15px; border-left: 2px solid #000000;">
                    <label style="font-weight: bold; color: #000000; margin-bottom: 8px; display: block;">Configura√ß√£o de Divis√£o em Blocos:</label>
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px;">
                        <div>
                            <label style="font-size: 0.85rem;">Caracteres por Bloco:</label>
                            <input type="number" id="blockCharsConfig" value="80" min="80" max="500" style="width: 100%; padding: 8px; border: 1px solid #d0d0d0; border-radius: 0;">
                        </div>
                        <div>
                            <label style="font-size: 0.85rem;">Reading Rate (c/s):</label>
                            <input type="number" id="readingRateConfig" value="10" min="5" max="30" style="width: 100%; padding: 8px; border: 1px solid #d0d0d0; border-radius: 0;">
                        </div>
                    </div>
                </div>

                <!-- Modo Autom√°tico -->
                <div style="background: #fafafa; padding: 15px; border-radius: 0; margin-bottom: 15px; border: 1px solid #d0d0d0;">
                    <label style="color: #000000; display: flex; align-items: center; cursor: pointer; font-size: 14px; font-weight: 500;">
                        <input type="checkbox" id="modoAutomaticoInicio" style="margin-right: 10px; width: 18px; height: 18px; cursor: pointer;">
                        MODO AUTOM√ÅTICO - Gera roteiro + documentos
                    </label>
                    <div id="configAutomatico" style="display: none; margin-top: 10px; padding-top: 10px; border-top: 1px solid #d0d0d0;">
                        <label style="color: #000000; display: block; margin-bottom: 5px; font-size: 13px;">Modelo para Documentos (Trilha + Personagens):</label>
                        <select id="modeloDocumentosInicio" style="padding: 8px; border-radius: 0; border: 1px solid #d0d0d0; font-size: 14px; width: 100%; margin-bottom: 10px;">
                            <option value="claude-opus-4-1-20250805">Claude Opus 4.1 (Qualidade M√°xima)</option>
                            <option value="claude-sonnet-4-20250514">Sonnet 4 (mais barato)</option>
                            <option value="claude-sonnet-4-5-20250929" selected>Sonnet 4.5 (Recomendado)</option>
                            <option value="claude-haiku-4-5">Haiku 4.5 (muito r√°pido e barato)</option>
                        </select>

                        <label style="color: #000000; display: block; margin-bottom: 5px; font-size: 13px;">Modelo para Takes (Prompts de Imagem):</label>
                        <select id="modeloTakesInicio" style="padding: 8px; border-radius: 0; border: 1px solid #d0d0d0; font-size: 14px; width: 100%;">
                            <option value="claude-opus-4-1-20250805">Claude Opus 4.1 (Qualidade M√°xima)</option>
                            <option value="claude-sonnet-4-20250514">Sonnet 4 (mais barato)</option>
                            <option value="claude-sonnet-4-5-20250929" selected>Sonnet 4.5 (Recomendado)</option>
                            <option value="claude-haiku-4-5">Haiku 4.5 (muito r√°pido e barato)</option>
                        </select>

                        <div style="color: #666666; font-size: 12px; margin-top: 8px;">
                            Tempo estimado: ~2-3 minutos | Custo: ~$0.80-$1.20
                        </div>
                    </div>
                </div>

                <button id="generateBtn" style="font-size: 14px; padding: 15px; font-weight: 500;">
                    <span id="generateBtnText">GERAR ROTEIRO</span>
                </button>

                <div class="progress" id="progress">
                    <span id="progressText">Gerando...</span>
                    <span id="timer" style="display: none; margin-left: 10px; font-weight: 500;">0:00</span>

                    <!-- Barra de Progresso Visual -->
                    <div style="width: 100%; background: #e0e0e0; border-radius: 0; margin-top: 15px; height: 30px; overflow: hidden;">
                        <div id="progressBar" style="width: 0%; height: 100%; background: #000000; transition: width 0.3s ease; display: flex; align-items: center; justify-content: center; color: white; font-weight: 500; font-size: 14px;">
                            <span id="progressPercent">0%</span>
                        </div>
                    </div>

                    <!-- Contadores de Caracteres -->
                    <div id="charCounters" style="display: none; margin-top: 15px; padding: 12px; background: #fafafa; border-radius: 0; font-size: 0.85rem; border: 1px solid #e0e0e0;">
                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px;">
                            <div>
                                <strong>Roteiro:</strong>
                                <div id="roteiroChars" style="font-size: 1.1rem; font-weight: 500; color: #000000;">0 caracteres</div>
                            </div>
                            <div>
                                <strong>Total (com docs):</strong>
                                <div id="totalCharsDisplay" style="font-size: 1.1rem; font-weight: 500; color: #000000;">0 caracteres</div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Outputs -->
            <div class="output-section">
                <h2>Output</h2>
                <div class="messages" id="messages">
                    <div class="message system">
                        <div class="message-label">Sistema</div>
                        <div class="message-content">Preencha os campos e clique em "Gerar Roteiro"</div>
                    </div>
                </div>

                <div class="downloads" id="downloads">
                    <h2>Downloads</h2>

                    <!-- Bot√µes Principais -->
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-bottom: 15px;">
                        <button id="downloadTudo" class="download-btn" style="background: #000000; color: white; font-size: 14px; font-weight: 500; padding: 15px;">
                            BAIXAR TODOS OS DOCUMENTOS
                        </button>
                        <button id="btnHistorico" class="download-btn" style="background: #4CAF50; color: white; font-size: 14px; font-weight: 500; padding: 15px;">
                            üìö HIST√ìRICO
                        </button>
                    </div>

                    <!-- Bot√£o JSON -->
                    <button id="downloadJSON" class="download-btn" style="background: #000000; color: white; font-size: 14px; font-weight: 500; padding: 12px; margin-bottom: 15px;">
                        BAIXAR JSON (Documenta√ß√£o Completa)
                    </button>

                    <!-- Bot√µes Individuais -->
                    <button class="download-btn" id="downloadCompleto">Baixar Roteiro Completo</button>
                    <button class="download-btn" id="downloadTakes">Baixar Takes</button>
                    <button class="download-btn" id="downloadPersonagens">Baixar Personagens</button>
                    <button class="download-btn" id="downloadSRT">Baixar SRT</button>
                </div>
            </div>
        </div>

        <!-- Modal de Hist√≥rico -->
        <div id="modalHistorico" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.7); z-index: 1000; overflow-y: auto;">
            <div style="background: white; max-width: 900px; margin: 50px auto; padding: 30px; border-radius: 8px; box-shadow: 0 4px 20px rgba(0,0,0,0.3);">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
                    <h2 style="margin: 0; color: #000;">üìö Hist√≥rico de Roteiros</h2>
                    <button id="btnFecharHistorico" style="background: #f44336; color: white; border: none; padding: 10px 20px; border-radius: 4px; cursor: pointer; font-size: 16px;">‚úñ Fechar</button>
                </div>
                <p style="color: #666; margin-bottom: 20px;">Roteiros salvos automaticamente (√∫ltimos 10)</p>
                <div id="listaHistorico" style="display: flex; flex-direction: column; gap: 15px;">
                    <!-- Itens do hist√≥rico ser√£o inseridos aqui -->
                </div>
            </div>
        </div>

        <!-- Se√ß√£o de Import de Blocos (oculta) -->
        <div class="container" style="margin-top: 30px; display: none;">
            <div style="background: #fafafa; padding: 20px; border-radius: 6px; border: 1px solid #e0e0e0; box-shadow: 0 1px 3px rgba(0, 0, 0, 0.05);">
                <h2 style="color: #000000; margin-top: 0; font-weight: 500; text-transform: uppercase; letter-spacing: 1px; font-size: 0.75rem;">Importar Blocos e Gerar Takes</h2>
                <p style="color: #666666; margin-bottom: 15px; font-size: 14px;">
                    Fa√ßa upload do arquivo <strong>blocos.txt</strong> para gerar apenas os takes, sem precisar gerar o roteiro novamente.
                </p>

                <div style="display: grid; grid-template-columns: 1fr 1fr auto; gap: 15px; align-items: end;">
                    <div>
                        <label style="color: #000000; display: block; margin-bottom: 8px; font-weight: 500;">Arquivo blocos.txt:</label>
                        <input type="file" id="blocosFileInput" accept=".txt" style="padding: 10px; border-radius: 6px; border: 1px solid #d0d0d0; background: white; width: 100%; font-size: 14px;">
                    </div>

                    <div>
                        <label style="color: #000000; display: block; margin-bottom: 8px; font-weight: 500;">Personagens (opcional):</label>
                        <div style="font-size: 11px; color: #999999; margin-bottom: 6px;">Se n√£o enviar, aparecer√° "[Personagem n√£o encontrado]"</div>
                        <input type="file" id="personagensFileInput" accept=".txt" style="padding: 10px; border-radius: 6px; border: 1px solid #d0d0d0; background: white; width: 100%; font-size: 14px;">
                    </div>

                    <div>
                        <label style="color: #000000; display: block; margin-bottom: 8px; font-weight: 500;">Modelo:</label>
                        <select id="modeloTakesImport" style="padding: 10px; border-radius: 6px; border: 1px solid #d0d0d0; font-size: 14px; width: 200px;">
                            <option value="claude-sonnet-4-20250514">Sonnet 4 (mais barato)</option>
                            <option value="claude-sonnet-4-5-20250929">Sonnet 4.5 (recomendado)</option>
                            <option value="claude-opus-4-1-20250805">Opus 4.1 (melhor qualidade)</option>
                            <option value="claude-haiku-4-5" selected>Haiku 4.5 (mais r√°pido e barato)</option>
                        </select>
                    </div>
                </div>

                <button id="importBlocosBtn" class="download-btn" disabled style="background: #000000; color: white; font-size: 14px; font-weight: 500; padding: 15px; margin-top: 15px; width: 100%;">
                    GERAR TAKES A PARTIR DOS BLOCOS
                    <div style="font-size: 12px; font-weight: normal; margin-top: 5px;">Custo: ~$0.08 (depende do n√∫mero de blocos)</div>
                </button>

                <!-- Status Import -->
                <div id="importStatus" style="margin-top: 15px; padding: 15px; background: #f5f5f5; border-radius: 6px; color: #000000; display: none; border: 1px solid #e0e0e0;">
                    <strong>Status:</strong>
                    <div id="importStatusText" style="margin-top: 8px; margin-bottom: 12px;"></div>

                    <!-- Barra de Progresso -->
                    <div style="width: 100%; background: #e0e0e0; border-radius: 6px; height: 30px; overflow: hidden;">
                        <div id="importProgressBar" style="width: 0%; height: 100%; background: #000000; transition: width 0.3s ease; display: flex; align-items: center; justify-content: center; color: white; font-weight: 500; font-size: 14px;">
                            <span id="importProgressPercent">0%</span>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Ferramentas de Manipula√ß√£o -->
        <div id="tools" class="container" style="display: none; margin-top: 30px;">
            <h1 style="font-weight: 300; letter-spacing: -0.5px;">Ferramentas de Manipula√ß√£o</h1>

            <!-- Se√ß√£o de IA -->
            <div style="background: #fafafa; padding: 20px; border-radius: 0; margin-bottom: 20px; border: 1px solid #e0e0e0;">
                <h2 style="color: #000000; margin-top: 0; font-weight: 500; text-transform: uppercase; letter-spacing: 1px; font-size: 0.75rem;">Gera√ß√£o com IA</h2>

                <!-- Configura√ß√µes -->
                <div style="display: grid; grid-template-columns: 1fr auto; gap: 15px; margin-bottom: 15px; align-items: center;">
                    <div>
                        <label style="color: #000000; display: block; margin-bottom: 5px; font-weight: 500;">Modelo para Documentos:</label>
                        <select id="modeloDocumentos" style="padding: 8px; border-radius: 0; border: 1px solid #d0d0d0; font-size: 14px; width: 100%;">
                            <option value="claude-sonnet-4-20250514" selected>Sonnet 4 (mais barato)</option>
                            <option value="claude-sonnet-4-5-20250929">Sonnet 4.5 (recomendado)</option>
                        </select>
                    </div>

                    <div style="text-align: right;">
                        <label style="color: #000000; display: block; margin-bottom: 5px; font-weight: 500; cursor: pointer;">
                            <input type="checkbox" id="modoAutomatico" style="margin-right: 5px; width: 18px; height: 18px; vertical-align: middle; cursor: pointer;">
                            Modo Autom√°tico
                        </label>
                        <span style="color: #666666; font-size: 11px; display: block;">Gera tudo em sequ√™ncia</span>
                    </div>
                </div>

                <!-- Bot√£o Autom√°tico (s√≥ aparece se modo autom√°tico estiver ativo) -->
                <div id="btnAutomaticoContainer" style="display: none; margin-bottom: 15px;">
                    <button id="gerarTodosBtn" class="download-btn" style="background: #000000; color: white; font-size: 14px; font-weight: 500; padding: 15px;">
                        GERAR TODOS OS DOCUMENTOS (~45s)
                        <div style="font-size: 12px; font-weight: normal; margin-top: 5px;">Trilha + Personagens + Takes | Custo: ~$0.12</div>
                    </button>
                </div>

                <!-- Bot√µes Individuais -->
                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 10px;">
                    <button id="gerarTrilhaBtn" class="download-btn" style="background: #000000;">Gerar Trilha Sonora</button>
                    <button id="gerarPersonagensBtn" class="download-btn" style="background: #000000;">Gerar Personagens</button>
                    <button id="gerarTakesBtn" class="download-btn" style="background: #666666;" disabled title="Gere os personagens primeiro">Gerar Takes</button>
                </div>

                <!-- Status -->
                <div id="aiStatus" style="margin-top: 15px; padding: 10px; background: #f5f5f5; border-radius: 0; color: #000000; display: none; border: 1px solid #e0e0e0;">
                    <strong>Status:</strong>
                    <div id="aiStatusText"></div>
                </div>
            </div>

            <div class="grid">
                <!-- Config da divis√£o -->
                <div class="input-section">
                    <h2>Configura√ß√µes</h2>

                    <div class="input-row">
                        <div>
                            <label>Caracteres por Bloco:</label>
                            <input type="number" id="blockChars" value="80" min="100" max="500">
                        </div>
                        <div>
                            <label>Palavras por Bloco:</label>
                            <input type="number" id="blockWords" value="17" min="5" max="100">
                        </div>
                        <div>
                            <label>Reading Rate (c/s):</label>
                            <input type="number" id="readingRate" value="10" min="5" max="30">
                        </div>
                    </div>

                    <button id="divideByCharsBtn" class="download-btn" style="background: #000000;">Dividir por Caracteres</button>
                    <button id="divideByWordsBtn" class="download-btn" style="background: #000000; margin-top: 10px;">Dividir por Palavras</button>
                    <button id="exportSrtBtn" class="download-btn" style="background: #000000; margin-top: 10px;">Exportar SRT</button>

                    <div id="blocksInfo" style="margin-top: 15px; padding: 10px; background: #fafafa; border-radius: 0; display: none; border: 1px solid #e0e0e0;">
                        <strong>Informa√ß√µes:</strong>
                        <div id="blocksStats"></div>
                    </div>
                </div>

                <!-- Preview dos blocos -->
                <div class="output-section">
                    <h2>Blocos Gerados</h2>
                    <div id="blocksPreview" style="max-height: 600px; overflow-y: auto; background: white; border: 1px solid #d0d0d0; border-radius: 0; padding: 15px;">
                        <p style="color: #999;">Divida o roteiro para ver os blocos aqui.</p>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // ====== SISTEMA DE HIST√ìRICO - VERS√ÉO 4.7 ======
        const MAX_HISTORY_ITEMS = 10;
        const HISTORY_KEY = 'scriptGeneratorHistory';

        // Salvar roteiro no hist√≥rico
        function saveToHistory() {
            try {
                const titulo = document.getElementById('title').value || 'Sem t√≠tulo';
                const agora = new Date();

                const roteiro = {
                    id: Date.now(),
                    titulo: titulo,
                    data: agora.toISOString(),
                    dataFormatada: agora.toLocaleString('pt-BR'),
                    files: { ...currentFiles },
                    docs: { ...currentDocs }
                };

                // Carregar hist√≥rico existente
                let historico = JSON.parse(localStorage.getItem(HISTORY_KEY) || '[]');

                // Adicionar novo item no in√≠cio
                historico.unshift(roteiro);

                // Limitar a 10 itens
                if (historico.length > MAX_HISTORY_ITEMS) {
                    historico = historico.slice(0, MAX_HISTORY_ITEMS);
                }

                // Salvar de volta
                localStorage.setItem(HISTORY_KEY, JSON.stringify(historico));

                console.log('‚úÖ Roteiro salvo no hist√≥rico:', titulo);
            } catch (error) {
                console.error('‚ùå Erro ao salvar hist√≥rico:', error);
            }
        }

        // Carregar hist√≥rico
        function loadHistory() {
            try {
                return JSON.parse(localStorage.getItem(HISTORY_KEY) || '[]');
            } catch (error) {
                console.error('‚ùå Erro ao carregar hist√≥rico:', error);
                return [];
            }
        }

        // Renderizar hist√≥rico no modal
        function renderHistory() {
            const lista = document.getElementById('listaHistorico');
            const historico = loadHistory();

            if (historico.length === 0) {
                lista.innerHTML = '<p style="color: #999; text-align: center; padding: 40px;">Nenhum roteiro salvo ainda. Gere um roteiro para come√ßar!</p>';
                return;
            }

            lista.innerHTML = historico.map(item => `
                <div style="background: #f9f9f9; border: 1px solid #ddd; border-radius: 6px; padding: 20px;">
                    <div style="display: flex; justify-content: space-between; align-items: start; margin-bottom: 15px;">
                        <div>
                            <h3 style="margin: 0 0 8px 0; color: #000; font-size: 18px;">${item.titulo}</h3>
                            <p style="margin: 0; color: #666; font-size: 14px;">üìÖ ${item.dataFormatada}</p>
                        </div>
                        <div style="display: flex; gap: 10px;">
                            <button onclick="restoreFromHistory(${item.id})" style="background: #4CAF50; color: white; border: none; padding: 10px 15px; border-radius: 4px; cursor: pointer; font-size: 14px;">
                                üìÇ Carregar
                            </button>
                            <button onclick="downloadFromHistory(${item.id})" style="background: #2196F3; color: white; border: none; padding: 10px 15px; border-radius: 4px; cursor: pointer; font-size: 14px;">
                                üíæ Baixar Tudo
                            </button>
                            <button onclick="deleteFromHistory(${item.id})" style="background: #f44336; color: white; border: none; padding: 10px 15px; border-radius: 4px; cursor: pointer; font-size: 14px;">
                                üóëÔ∏è Apagar
                            </button>
                        </div>
                    </div>
                    <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 10px; font-size: 13px; color: #666;">
                        <div>‚úÖ Roteiro: ${item.files?.hook ? 'Sim' : 'N√£o'}</div>
                        <div>üé¨ Takes: ${item.docs?.takes ? 'Sim' : 'N√£o'}</div>
                        <div>üë• Personagens: ${item.docs?.personagens ? 'Sim' : 'N√£o'}</div>
                    </div>
                </div>
            `).join('');
        }

        // Restaurar roteiro do hist√≥rico
        function restoreFromHistory(id) {
            try {
                const historico = loadHistory();
                const item = historico.find(r => r.id === id);

                if (!item) {
                    alert('‚ùå Roteiro n√£o encontrado!');
                    return;
                }

                // Restaurar arquivos
                currentFiles = { ...item.files };
                currentDocs = { ...item.docs };

                // Atualizar interface
                document.getElementById('title').value = item.titulo;

                // Mostrar downloads
                document.getElementById('downloads').style.display = 'block';
                document.getElementById('tools').style.display = 'block';

                // Atualizar contadores
                updateCharCounters();

                // Fechar modal
                document.getElementById('modalHistorico').style.display = 'none';

                addMessage('Sistema', `‚úÖ Roteiro "${item.titulo}" carregado do hist√≥rico!`, 'system');
                console.log('‚úÖ Roteiro restaurado:', item.titulo);
            } catch (error) {
                console.error('‚ùå Erro ao restaurar roteiro:', error);
                alert('‚ùå Erro ao carregar roteiro!');
            }
        }

        // Baixar tudo de um roteiro do hist√≥rico
        function downloadFromHistory(id) {
            try {
                const historico = loadHistory();
                const item = historico.find(r => r.id === id);

                if (!item) {
                    alert('‚ùå Roteiro n√£o encontrado!');
                    return;
                }

                // Temporariamente carregar os arquivos
                const tempFiles = { ...currentFiles };
                const tempDocs = { ...currentDocs };

                currentFiles = { ...item.files };
                currentDocs = { ...item.docs };

                // Baixar tudo (usar fun√ß√£o existente)
                document.getElementById('downloadTudo').click();

                // Restaurar arquivos anteriores
                currentFiles = tempFiles;
                currentDocs = tempDocs;

                console.log('‚úÖ Download iniciado:', item.titulo);
            } catch (error) {
                console.error('‚ùå Erro ao baixar roteiro:', error);
                alert('‚ùå Erro ao baixar arquivos!');
            }
        }

        // Deletar roteiro do hist√≥rico
        function deleteFromHistory(id) {
            if (!confirm('üóëÔ∏è Tem certeza que deseja apagar este roteiro do hist√≥rico?')) {
                return;
            }

            try {
                let historico = loadHistory();
                historico = historico.filter(r => r.id !== id);
                localStorage.setItem(HISTORY_KEY, JSON.stringify(historico));
                renderHistory();
                console.log('‚úÖ Roteiro apagado do hist√≥rico');
            } catch (error) {
                console.error('‚ùå Erro ao deletar roteiro:', error);
                alert('‚ùå Erro ao apagar roteiro!');
            }
        }

        // Event listeners para o modal
        document.getElementById('btnHistorico').addEventListener('click', () => {
            renderHistory();
            document.getElementById('modalHistorico').style.display = 'block';
        });

        document.getElementById('btnFecharHistorico').addEventListener('click', () => {
            document.getElementById('modalHistorico').style.display = 'none';
        });

        // Fechar modal clicando fora
        document.getElementById('modalHistorico').addEventListener('click', (e) => {
            if (e.target.id === 'modalHistorico') {
                document.getElementById('modalHistorico').style.display = 'none';
            }
        });

        // ====== SISTEMA ANTI-CACHE - VERS√ÉO 2.5 ======
        // FOR√áAR NAVEGADOR A N√ÉO USAR CACHE
        if ('caches' in window) {
            caches.keys().then(names => {
                names.forEach(name => {
                    caches.delete(name);
                });
            });
        }

        // Mostrar hora da √∫ltima atualiza√ß√£o assim que a p√°gina carregar
        window.addEventListener('DOMContentLoaded', () => {
            console.log('Script Generator v4.9.0');

            // Carregar hist√≥rico logo ao abrir o site
            const historico = loadHistory();
            if (historico.length > 0) {
                console.log(`üìö ${historico.length} roteiro(s) encontrado(s) no hist√≥rico`);
                renderHistory();
            }
        });

        // Verificar autentica√ß√£o
        const authToken = localStorage.getItem('authToken');
        if (!authToken) {
            window.location.href = 'login.html';
        }

        // Mostrar nome do usu√°rio
        const user = localStorage.getItem('user');
        if (user) {
            try {
                const userData = JSON.parse(user);
                document.getElementById('userName').textContent = `USER: ${userData.USERNAME || 'NARDOTO'}`;
            } catch (e) {
                document.getElementById('userName').textContent = `USER: ${user}`;
            }
        }

        // Bot√£o de logout
        document.getElementById('logoutBtn').addEventListener('click', () => {
            localStorage.removeItem('authToken');
            localStorage.removeItem('user');
            window.location.href = 'login.html';
        });

        // Toggle campo extra para Estudo Teol√≥gico
        const contentType = document.getElementById('contentType');
        const extraContentField = document.getElementById('extraContentField');

        contentType.addEventListener('change', () => {
            if (contentType.value === 'estudo') {
                extraContentField.style.display = 'block';
            } else {
                extraContentField.style.display = 'none';
            }
        });

        // Fun√ß√£o para fazer requisi√ß√µes autenticadas
        function fetchWithAuth(url, options = {}) {
            const token = localStorage.getItem('authToken');
            if (!token) {
                window.location.href = 'login.html';
                return Promise.reject('No token');
            }

            options.headers = {
                ...options.headers,
                'Authorization': `Bearer ${token}`
            };

            return fetch(url, options).then(res => {
                if (res.status === 401) {
                    // Token inv√°lido/expirado
                    localStorage.removeItem('authToken');
                    localStorage.removeItem('user');
                    window.location.href = 'login.html';
                    return Promise.reject('Unauthorized');
                }
                return res;
            });
        }

        const messages = document.getElementById('messages');
        const generateBtn = document.getElementById('generateBtn');
        const generateBtnText = document.getElementById('generateBtnText');
        const progress = document.getElementById('progress');
        const downloads = document.getElementById('downloads');
        const timer = document.getElementById('timer');
        const progressText = document.getElementById('progressText');
        const progressBar = document.getElementById('progressBar');
        const progressPercent = document.getElementById('progressPercent');
        const charCounters = document.getElementById('charCounters');
        const roteiroChars = document.getElementById('roteiroChars');
        const totalCharsDisplay = document.getElementById('totalCharsDisplay');

        // Modo Autom√°tico no In√≠cio
        const modoAutomaticoInicio = document.getElementById('modoAutomaticoInicio');
        const configAutomatico = document.getElementById('configAutomatico');
        const modeloDocumentosInicio = document.getElementById('modeloDocumentosInicio');
        const modeloTakesInicio = document.getElementById('modeloTakesInicio');

        // Sincronizar os dois checkboxes de modo autom√°tico
        modoAutomaticoInicio.addEventListener('change', () => {
            const modoAuto = document.getElementById('modoAutomatico');
            if (modoAuto) modoAuto.checked = modoAutomaticoInicio.checked;
        });

        // Ferramentas
        const tools = document.getElementById('tools');
        const divideByCharsBtn = document.getElementById('divideByCharsBtn');
        const divideByWordsBtn = document.getElementById('divideByWordsBtn');
        const exportSrtBtn = document.getElementById('exportSrtBtn');
        const blocksPreview = document.getElementById('blocksPreview');
        const blocksInfo = document.getElementById('blocksInfo');
        const blocksStats = document.getElementById('blocksStats');

        // Ferramentas de IA
        const gerarTrilhaBtn = document.getElementById('gerarTrilhaBtn');
        const gerarPersonagensBtn = document.getElementById('gerarPersonagensBtn');
        const gerarTakesBtn = document.getElementById('gerarTakesBtn');
        const gerarTodosBtn = document.getElementById('gerarTodosBtn');
        const modeloDocumentos = document.getElementById('modeloDocumentos');
        const modoAutomatico = document.getElementById('modoAutomatico');
        const btnAutomaticoContainer = document.getElementById('btnAutomaticoContainer');
        const aiStatus = document.getElementById('aiStatus');
        const aiStatusText = document.getElementById('aiStatusText');

        // Sincronizar checkbox da se√ß√£o com o do topo
        if (modoAutomatico) {
            modoAutomatico.addEventListener('change', () => {
                modoAutomaticoInicio.checked = modoAutomatico.checked;
            });
        }

        let currentFiles = {};
        let currentDocs = {}; // Armazena documentos gerados (trilha, personagens, takes, srt, blocos)
        let currentBlocks = [];
        let currentPersonagens = null; // Objeto com personagens gerados
        let startTime = null;
        let timerInterval = null;
        let startTimeTotal = null; // Tempo total de gera√ß√£o (roteiro + documentos)
        let modoAutoAtivado = false; // Armazena se modo autom√°tico foi ativado ANTES de gerar
        const PAUSE_TIME = 0.9; // Pausa entre blocos em segundos

        // Fun√ß√£o para atualizar barra de progresso
        function updateProgress(percent, text) {
            progressBar.style.width = percent + '%';
            // Se tem texto descritivo, mostrar ele; sen√£o mostrar porcentagem
            if (text) {
                progressPercent.textContent = text;
                progressText.textContent = text;
            } else {
                progressPercent.textContent = percent + '%';
            }
        }

        // Fun√ß√£o para atualizar contadores de caracteres
        function updateCharCounters() {
            // Contar caracteres do roteiro
            let roteiroTotal = 0;
            if (currentFiles.hook) roteiroTotal += currentFiles.hook.length;
            if (currentFiles.topicos) {
                currentFiles.topicos.forEach(t => roteiroTotal += t.length);
            }

            // Contar caracteres de todos os documentos
            let docsTotal = roteiroTotal;
            if (currentFiles.estrutura) docsTotal += currentFiles.estrutura.length;
            if (currentFiles.trilha) docsTotal += currentFiles.trilha.length;
            if (currentFiles.personagens) docsTotal += currentFiles.personagens.length;
            if (currentFiles.takes) docsTotal += currentFiles.takes.length;

            roteiroChars.textContent = roteiroTotal.toLocaleString() + ' caracteres';
            totalCharsDisplay.textContent = docsTotal.toLocaleString() + ' caracteres';
            charCounters.style.display = 'block';
        }

        // Fun√ß√µes do cron√¥metro
        function startTimer() {
            startTime = Date.now();
            timer.style.display = 'inline';
            timerInterval = setInterval(() => {
                const elapsed = Math.floor((Date.now() - startTime) / 1000);
                const minutes = Math.floor(elapsed / 60);
                const seconds = elapsed % 60;
                timer.textContent = `‚è±Ô∏è ${minutes}:${seconds.toString().padStart(2, '0')}`;
            }, 1000);
        }

        function stopTimer() {
            if (timerInterval) {
                clearInterval(timerInterval);
                timerInterval = null;
            }
        }

        // Toggle Modo Autom√°tico no In√≠cio
        modoAutomaticoInicio.addEventListener('change', () => {
            if (modoAutomaticoInicio.checked) {
                configAutomatico.style.display = 'block';
                generateBtnText.textContent = 'GERAR TUDO AUTOMATICAMENTE';
                generateBtn.style.background = '#000000';
                generateBtn.style.color = 'white';
            } else {
                configAutomatico.style.display = 'none';
                generateBtnText.textContent = 'GERAR ROTEIRO';
                generateBtn.style.background = '';
                generateBtn.style.color = '';
            }
        });

        function addMessage(label, content, type = 'assistant', data = {}) {
            const msg = document.createElement('div');
            msg.className = `message ${type}`;

            let statsHTML = '';
            if (data.charCount !== undefined) {
                statsHTML = `
                    <div class="message-stats">
                        <div>üìä <span>${data.charCount}</span> caracteres (com espa√ßos)</div>
                        <div>üìù <span>${data.charCountNoSpaces}</span> caracteres (sem espa√ßos)</div>
                        <div>üìñ <span>${data.wordCount}</span> palavras</div>
                    </div>
                `;
            }

            let promptHTML = '';
            if (data.prompt) {
                const promptId = `prompt-${Date.now()}-${Math.random()}`;
                promptHTML = `
                    <button class="prompt-toggle" onclick="document.getElementById('${promptId}').classList.toggle('visible')">
                        üëÅÔ∏è Ver Prompt Enviado
                    </button>
                    <div class="prompt-content" id="${promptId}">${data.prompt}</div>
                `;
            }

            let progressHTML = '';
            if (data.progress) {
                progressHTML = `<div style="margin-top: 8px; color: #667eea; font-weight: 600; font-size: 0.9rem;">‚è≥ ${data.progress}</div>`;
            }

            msg.innerHTML = `
                <div class="message-label">${label}</div>
                ${progressHTML}
                <div class="message-content">${content}</div>
                ${statsHTML}
                ${promptHTML}
            `;
            messages.appendChild(msg);
            messages.scrollTop = messages.scrollHeight;
        }

        // Fun√ß√£o para sanitizar nome de arquivo
        function sanitizeFilename(text) {
            return text
                .replace(/[<>:"/\\|?*]/g, '') // Remove caracteres inv√°lidos
                .replace(/\s+/g, '_') // Substitui espa√ßos por underscore
                .substring(0, 100); // Limita tamanho
        }

        function downloadFile(filename, content) {
            const blob = new Blob([content], { type: 'text/plain;charset=utf-8' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            a.click();
            URL.revokeObjectURL(url);
        }

        // Fun√ß√£o para obter o t√≠tulo sanitizado
        function getTituloArquivo() {
            const titulo = document.getElementById('title').value.trim();
            return titulo ? sanitizeFilename(titulo) : 'roteiro';
        }

        generateBtn.addEventListener('click', async () => {
            messages.innerHTML = '';
            downloads.style.display = 'none';
            tools.style.display = 'none';
            progress.style.display = 'block';
            generateBtn.disabled = true;

            // Iniciar cron√¥metro
            startTimer();
            startTimeTotal = Date.now(); // Marca in√≠cio da gera√ß√£o completa

            // Resetar progresso
            updateProgress(0, 'Iniciando...');

            currentFiles = {};
            currentBlocks = [];

            // CAPTURAR modo autom√°tico AGORA (antes de gerar)
            modoAutoAtivado = modoAutomaticoInicio.checked || (modoAutomatico && modoAutomatico.checked);
            console.log('üéØ Modo autom√°tico capturado ao clicar em Gerar:', modoAutoAtivado);

            const selectedContentType = document.getElementById('contentType').value;
            const tipoConteudoMap = {
                'historia': 'historias',
                'curiosidade': 'curiosidades',
                'estudo': 'estudos'
            };

            const input = {
                title: document.getElementById('title').value,
                synopsis: document.getElementById('synopsis').value,
                knowledgeBase: selectedContentType === 'estudo' ? document.getElementById('extraContent').value : '',
                tipoConteudo: tipoConteudoMap[selectedContentType],
                language: document.getElementById('language').value,
                numTopics: parseInt(document.getElementById('numTopics').value),
                numSubtopics: parseInt(document.getElementById('numSubtopics').value),
                hookChars: parseInt(document.getElementById('hookChars').value),
                totalChars: parseInt(document.getElementById('totalChars').value),
                model: document.getElementById('claudeModel').value
            };

            try {
                const response = await fetch('/api/gerar', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(input)
                });

                const reader = response.body.getReader();
                const decoder = new TextDecoder();
                const chunkBuffer = {}; // Buffer para armazenar chunks tempor√°rios

                while (true) {
                    const { done, value } = await reader.read();
                    if (done) {
                        console.log('üèÅ Stream terminado');

                        // Processar chunks pendentes antes de terminar
                        const chunksKeys = Object.keys(chunkBuffer);
                        if (chunksKeys.length > 0) {
                            console.log(`‚ö†Ô∏è Processando ${chunksKeys.length} chunks pendentes...`);
                            chunksKeys.forEach(key => {
                                const buffer = chunkBuffer[key];
                                console.log(`   üì¶ Chunk pendente: ${key} com ${buffer.chunks.length} partes`);

                                // Juntar chunks existentes mesmo que n√£o esteja completo
                                const fullContent = buffer.chunks.filter(c => c !== undefined).join('');

                                if (fullContent.length > 0) {
                                    console.log(`   ‚úÖ Reconstruindo ${fullContent.length} chars de ${key}`);

                                    // Processar como mensagem mesmo sem ter todos os chunks
                                    const fullData = {
                                        ...buffer.metadata,
                                        content: fullContent,
                                        isChunk: false
                                    };

                                    // Determinar label baseado no step
                                    let label = 'IA';
                                    if (fullData.step === 'estrutura') label = 'üìã Estrutura';
                                    else if (fullData.step === 'hook') label = 'üé£ Hook';
                                    else if (fullData.step === 'conclusao') label = 'üé¨ Conclus√£o';
                                    else if (fullData.step && fullData.step.startsWith('topico')) {
                                        const topicoNum = fullData.step.match(/\d+/)?.[0];
                                        if (topicoNum) {
                                            label = `üìñ T√≥pico ${topicoNum}`;
                                            currentFiles[`topico${topicoNum}`] = fullContent;
                                            currentDocs[`topico${topicoNum}`] = fullContent;
                                        }
                                    }

                                    addMessage(label, fullContent, 'assistant', {
                                        prompt: fullData.prompt,
                                        charCount: fullData.charCount,
                                        charCountNoSpaces: fullData.charCountNoSpaces,
                                        wordCount: fullData.wordCount
                                    });
                                }
                            });
                        }

                        // VERIFICAR SE TEMOS TUDO E INICIAR MODO AUTOM√ÅTICO
                        console.log('üîç Verificando se gera√ß√£o est√° completa...');
                        console.log('üì¶ Arquivos:', Object.keys(currentFiles));

                        const numTopics = parseInt(document.getElementById('numTopics').value);
                        const temTodosTopicos = Array.from({length: numTopics}, (_, i) => i + 1)
                            .every(n => currentFiles[`topico${n}`]);

                        console.log(`   Estrutura: ${currentFiles.estrutura ? '‚úÖ' : '‚ùå'}`);
                        console.log(`   Hook: ${currentFiles.hook ? '‚úÖ' : '‚ùå'}`);
                        console.log(`   T√≥picos: ${temTodosTopicos ? '‚úÖ TODOS' : '‚ùå FALTANDO'}`);
                        console.log(`   Conclus√£o: ${currentFiles.conclusao ? '‚úÖ' : '‚ùå'}`);

                        if (currentFiles.estrutura && currentFiles.hook && temTodosTopicos && currentFiles.conclusao) {
                            console.log('‚úÖ Roteiro COMPLETO!');

                            // Reconstruir array de t√≥picos
                            const topicosArray = [];
                            for (let i = 1; i <= numTopics; i++) {
                                if (currentFiles[`topico${i}`]) {
                                    topicosArray.push(currentFiles[`topico${i}`]);
                                }
                            }
                            currentFiles.topicos = topicosArray;
                            currentDocs.topicos = topicosArray;
                            console.log(`‚úÖ Array: ${topicosArray.length} t√≥picos`);

                            // Atualizar UI
                            updateCharCounters();
                            downloads.style.display = 'block';
                            tools.style.display = 'block';

                            // Verificar modo autom√°tico
                            if (modoAutoAtivado) {
                                console.log('üöÄ MODO AUTOM√ÅTICO ATIVADO!');
                                updateProgress(70, 'üìÑ Preparando documentos...');
                                addMessage('Sistema', '‚úÖ Roteiro completo! Iniciando gera√ß√£o autom√°tica...', 'system');

                                gerarDocumentosAutomaticamente().then(() => {
                                    stopTimer();
                                    const tempo = Date.now() - startTimeTotal;
                                    const min = Math.floor(tempo / 60000);
                                    const seg = Math.floor((tempo % 60000) / 1000);
                                    addMessage('Sistema', `‚è±Ô∏è TEMPO: ${min}:${seg.toString().padStart(2, '0')}`, 'system');
                                    addMessage('Sistema', 'üéâ TUDO PRONTO!', 'system');
                                    updateProgress(100, '‚úÖ Conclu√≠do!');
                                }).catch(err => {
                                    console.error('‚ùå Erro:', err);
                                    addMessage('Erro', `‚ùå ${err.message}`, 'error');
                                });
                            } else {
                                updateProgress(100, '‚úÖ Completo!');
                                stopTimer();
                            }
                        } else {
                            console.log('‚ö†Ô∏è INCOMPLETO!');
                            updateProgress(100, '‚ö†Ô∏è Incompleto');
                        }

                        break;
                    }

                    const chunk = decoder.decode(value);

                    // SSE: eventos s√£o separados por "\n\ndata: " (quebra dupla + pr√≥ximo evento)
                    // Isso evita quebrar JSON no meio quando content tem \n dentro
                    const lines = chunk.split('\n');

                    console.log(`üì• Recebido ${lines.length} linhas`);

                    for (const line of lines) {
                        if (!line.trim() || !line.startsWith('data: ')) continue;

                        console.log('üîç Processando evento SSE...');
                        try {
                            // Remover "data: " do in√≠cio
                            let jsonStr = line.substring(6);

                            // PROBLEMA: M√∫ltiplos eventos podem vir grudados: {...}\n\ndata: {...}\n\n
                            // Solu√ß√£o: Se tem \n\ndata: dentro, pegar s√≥ at√© ele
                            if (jsonStr.includes('\\n\\ndata:')) {
                                jsonStr = jsonStr.split('\\n\\ndata:')[0];
                            }

                            // Remover \n\n literal do final se existir
                            if (jsonStr.endsWith('\\n\\n')) {
                                jsonStr = jsonStr.slice(0, -4);
                            }

                            jsonStr = jsonStr.trim();
                            if (!jsonStr) continue;

                            const data = JSON.parse(jsonStr);
                            console.log(`‚úÖ Parseado: type=${data.type}, step=${data.step}, isChunk=${data.isChunk}`);

                                    // Processar chunks de mensagens grandes
                                    if (data.isChunk) {
                                        const key = `${data.step}_${data.type}`;

                                        // Inicializar buffer se primeira vez
                                        if (!chunkBuffer[key]) {
                                            chunkBuffer[key] = {
                                                chunks: [],
                                                metadata: { ...data }
                                            };
                                        }

                                        // Adicionar chunk ao buffer
                                        chunkBuffer[key].chunks[data.chunkIndex] = data.content;

                                        console.log(`üì¶ Chunk ${data.chunkIndex + 1}/${data.totalChunks} recebido para ${key}`);

                                        // Se √© o √∫ltimo chunk, processar a mensagem completa
                                        if (data.isLastChunk) {
                                            // Juntar todos os chunks
                                            const fullContent = chunkBuffer[key].chunks.join('');

                                            // Criar objeto de dados completo
                                            const fullData = {
                                                ...chunkBuffer[key].metadata,
                                                content: fullContent,
                                                isChunk: false
                                            };

                                            console.log(`‚úÖ Mensagem completa reconstru√≠da: ${fullContent.length} chars`);

                                            // Limpar buffer
                                            delete chunkBuffer[key];

                                            // Processar como mensagem normal
                                            data.type = fullData.type;
                                            data.step = fullData.step;
                                            data.content = fullData.content;
                                            data.prompt = fullData.prompt;
                                            data.charCount = fullData.charCount;
                                            data.charCountNoSpaces = fullData.charCountNoSpaces;
                                            data.wordCount = fullData.wordCount;
                                        } else {
                                            // Ainda esperando mais chunks, n√£o processar ainda
                                            continue;
                                        }
                                    }

                                    if (data.type === 'step') {
                                        const progressText = data.progress || `üîÑ ${data.step} - ${data.status}`;
                                        addMessage('Sistema', progressText, 'system', { progress: data.progress });

                                        // Atualizar barra de progresso baseado no passo
                                        if (data.step === 'estrutura') {
                                            updateProgress(10, 'Gerando estrutura...');
                                        } else if (data.step === 'hook') {
                                            updateProgress(20, 'Gerando hook...');
                                        }
                                    } else if (data.type === 'message') {
                                        let label;
                                        if (data.step === 'estrutura') {
                                            label = 'üìã Estrutura';
                                            currentFiles.estrutura = data.content;
                                            currentDocs.estrutura = data.content;
                                        } else if (data.step === 'hook') {
                                            label = 'üé£ Hook';
                                            currentFiles.hook = data.content;
                                            currentDocs.hook = data.content;
                                        } else if (data.step === 'conclusao') {
                                            label = 'üé¨ Conclus√£o';
                                            currentFiles.conclusao = data.content;
                                            currentDocs.conclusao = data.content;
                                        } else if (data.step && data.step.includes('subtopico')) {
                                            const match = data.step.match(/topico(\d+)_subtopico(\d+)/);
                                            if (match) {
                                                label = `üìù T√≥pico ${match[1]} - Subt√≥pico ${match[2]}`;
                                            } else {
                                                label = 'IA';
                                            }
                                        } else if (data.step && data.step.startsWith('topico')) {
                                            const topicoNum = data.step.match(/\d+/)?.[0];
                                            if (topicoNum) {
                                                label = `üìñ T√≥pico ${topicoNum}`;
                                                currentFiles[`topico${topicoNum}`] = data.content;
                                                currentDocs[`topico${topicoNum}`] = data.content;
                                            } else {
                                                label = `üìñ ${data.step.replace('topico', 'T√≥pico ')}`;
                                            }
                                        } else {
                                            label = 'IA';
                                        }

                                        // Log para debug
                                        console.log(`üìù Mensagem recebida: ${label} (${data.step})`);
                                        console.log(`   Tamanho: ${data.content ? data.content.length : 0} chars`);

                                        addMessage(label, data.content, 'assistant', {
                                            prompt: data.prompt,
                                            charCount: data.charCount,
                                            charCountNoSpaces: data.charCountNoSpaces,
                                            wordCount: data.wordCount
                                        });
                                    } else if (data.type === 'topico_complete') {
                                        const percent = data.percentComplete || 0;
                                        const emoji = percent >= 100 ? '‚úÖ' : percent >= 80 ? '‚ö†Ô∏è' : '‚ùå';
                                        addMessage('Sistema',
                                            `${emoji} T√≥pico ${data.topicoNum} completo: ${data.totalChars} chars de ${data.expectedChars} esperados (${percent}%)`,
                                            'system'
                                        );

                                        // Atualizar progresso: 20% a 70% distribu√≠do entre t√≥picos
                                        const numTopics = parseInt(document.getElementById('numTopics').value);
                                        const progressoParcial = 20 + (data.topicoNum / numTopics) * 50;
                                        updateProgress(Math.round(progressoParcial), `T√≥pico ${data.topicoNum}/${numTopics} completo`);
                                    } else if (data.type === 'complete') {
                                        console.log('‚úÖ Evento complete recebido:', data);

                                        // Verificar se √© o novo formato lightweight
                                        if (data.status === 'success' && data.summary) {
                                            console.log('üìä Complete event (lightweight):', data.summary);
                                            console.log(`   Total size: ${data.summary.totalSize} chars`);
                                            console.log(`   Topics: ${data.summary.topicosCount} (${data.summary.topicosLengths.join(', ')} chars)`);

                                            // Usar arquivos j√° salvos durante gera√ß√£o
                                            console.log('üì¶ Usando arquivos salvos durante gera√ß√£o');
                                            console.log('üì¶ Arquivos dispon√≠veis:', Object.keys(currentFiles));

                                            // Reconstruir array de t√≥picos a partir dos t√≥picos individuais
                                            const topicosArray = [];
                                            for (let i = 1; i <= data.summary.topicosCount; i++) {
                                                const topicoKey = `topico${i}`;
                                                if (currentFiles[topicoKey]) {
                                                    topicosArray.push(currentFiles[topicoKey]);
                                                    if (currentDocs[topicoKey]) {
                                                        // Tamb√©m adicionar ao currentDocs para consist√™ncia
                                                    }
                                                }
                                            }
                                            currentFiles.topicos = topicosArray;
                                            currentDocs.topicos = topicosArray;
                                            console.log(`‚úÖ Array de t√≥picos reconstru√≠do: ${topicosArray.length} t√≥picos`);
                                        } else if (data.files) {
                                            // Formato antigo com arquivos completos (n√£o deveria mais acontecer)
                                            console.log('‚ö†Ô∏è Complete event com arquivos completos (formato antigo)');
                                            currentFiles = { ...currentFiles, ...data.files };
                                        } else {
                                            // Fallback para formato desconhecido
                                            console.log('‚ö†Ô∏è Complete event sem files nem summary, usando arquivos salvos');
                                        }

                                        // Atualizar contadores
                                        updateCharCounters();

                                        // Sempre mostrar downloads e ferramentas
                                        downloads.style.display = 'block';
                                        tools.style.display = 'block';

                                        // Verificar se modo autom√°tico foi ativado
                                        console.log('üîç Verificando modo autom√°tico:', modoAutoAtivado);

                                        // Se n√£o √© modo autom√°tico, marcar como completo
                                        if (!modoAutoAtivado) {
                                            updateProgress(100, '‚úÖ Gera√ß√£o completa!');
                                        } else {
                                            // Se √© modo autom√°tico, deixar em 70% pois ainda vai gerar documentos
                                            updateProgress(70, 'üìÑ Preparando documentos...');
                                        }

                                        if (modoAutoAtivado) {
                                            addMessage('Sistema', '‚úÖ Roteiro completo! Iniciando gera√ß√£o autom√°tica de documentos...', 'system');
                                            console.log('üöÄ Chamando gerarDocumentosAutomaticamente()...');

                                            // Gerar documentos automaticamente (sem await pois n√£o estamos em fun√ß√£o async)
                                            gerarDocumentosAutomaticamente().then(() => {
                                                stopTimer();

                                                // Calcular e mostrar tempo total
                                                const tempoTotalMs = Date.now() - startTimeTotal;
                                                const minutos = Math.floor(tempoTotalMs / 60000);
                                                const segundos = Math.floor((tempoTotalMs % 60000) / 1000);
                                                const tempoFormatado = `${minutos}:${segundos.toString().padStart(2, '0')}`;

                                                addMessage('Sistema', `‚è±Ô∏è TEMPO TOTAL DE GERA√á√ÉO: ${tempoFormatado}`, 'system');
                                                addMessage('Sistema', 'üéâ TUDO PRONTO! Roteiro + Documentos gerados!', 'system');

                                                // Atualizar contadores finais
                                                updateCharCounters();

                                                // Salvar no hist√≥rico
                                                saveToHistory();
                                            }).catch(error => {
                                                console.error('Erro ao gerar documentos:', error);
                                                addMessage('Sistema', `‚ùå Erro ao gerar documentos: ${error.message}`, 'system');
                                                stopTimer();
                                            });
                                        } else {
                                            stopTimer();
                                            addMessage('Sistema', '‚úÖ Gera√ß√£o completa!', 'system');

                                            // Salvar no hist√≥rico (modo manual)
                                            saveToHistory();
                                        }
                                    } else if (data.type === 'error') {
                                        stopTimer();
                                        addMessage('Erro', data.error, 'error');
                                    }
                        } catch (e) {
                            console.error('‚ùå ERRO ao processar evento SSE:', e);
                            console.error('   Linha problem√°tica:', line);
                            console.error('   Stack:', e.stack);
                        }
                    }
                }
            } catch (error) {
                addMessage('Erro', error.message, 'error');
            }

            progress.style.display = 'none';
            generateBtn.disabled = false;
        });

        // Download buttons
        document.getElementById('downloadCompleto').addEventListener('click', () => {
            const completo = [
                currentFiles.hook,
                ...currentFiles.topicos
            ].join('\n\n');
            downloadFile('00_Roteiro_Completo.txt', completo);
        });

        document.getElementById('downloadTakes').addEventListener('click', () => {
            if (!currentDocs.takes) {
                alert('‚ùå Gere os takes primeiro usando modo autom√°tico!');
                return;
            }
            downloadFile('takes.txt', currentDocs.takes);
        });

        document.getElementById('downloadPersonagens').addEventListener('click', () => {
            if (!currentDocs.personagens) {
                alert('‚ùå Gere os personagens primeiro usando modo autom√°tico!');
                return;
            }
            downloadFile('personagens.txt', currentDocs.personagens);
        });

        document.getElementById('downloadSRT').addEventListener('click', () => {
            if (!currentDocs.srt) {
                alert('‚ùå Gere o SRT primeiro usando modo autom√°tico!');
                return;
            }
            downloadFile('roteiro.srt', currentDocs.srt);
        });

        // Bot√£o Download Tudo
        document.getElementById('downloadTudo').addEventListener('click', () => {
            if (!currentFiles.hook || !currentFiles.topicos) {
                alert('‚ùå Gere um roteiro primeiro!');
                return;
            }

            // Download de todos os arquivos gerados
            const arquivos = [];

            // Estrutura
            if (currentFiles.estrutura) {
                arquivos.push({ nome: '01_Estrutura.txt', conteudo: currentFiles.estrutura });
            }

            // Hook
            if (currentFiles.hook) {
                arquivos.push({ nome: '02_Hook.txt', conteudo: currentFiles.hook });
            }

            // T√≥picos
            if (currentFiles.topicos) {
                currentFiles.topicos.forEach((topico, i) => {
                    arquivos.push({ nome: `03_Topico_${i + 1}.txt`, conteudo: topico });
                });
            }

            // Roteiro Completo
            const completo = [currentFiles.hook, ...currentFiles.topicos].join('\n\n');
            arquivos.push({ nome: '00_Roteiro_Completo.txt', conteudo: completo });

            // Trilha
            if (currentFiles.trilha) {
                arquivos.push({ nome: '02_Trilha_Sonora.txt', conteudo: currentFiles.trilha });
            }

            // Personagens
            if (currentFiles.personagens) {
                arquivos.push({ nome: '04_Personagens_Descricoes.txt', conteudo: currentFiles.personagens });
            }

            // Blocos
            if (currentBlocks.length > 0) {
                const blocosTexto = currentBlocks.map((bloco, i) => `BLOCO ${i + 1}\n${bloco}`).join('\n\n');
                arquivos.push({ nome: 'blocos.txt', conteudo: blocosTexto });
            }

            // SRT (se houver blocos)
            if (currentBlocks.length > 0) {
                const readingRate = 12;
                const pauseTime = 0.9;
                let srtContent = '';
                let currentTime = 0;
                currentBlocks.forEach((block, index) => {
                    const text = block.trim();
                    if (!text) return;
                    const duration = text.length / readingRate;
                    const startTime = currentTime;
                    const endTime = currentTime + duration;
                    srtContent += `${index + 1}\n${formatSrtTimestamp(startTime)} --> ${formatSrtTimestamp(endTime)}\n${text}\n\n`;
                    currentTime = endTime + pauseTime;
                });
                if (srtContent.trim()) {
                    arquivos.push({ nome: 'roteiro.srt', conteudo: srtContent.trim() });
                }
            }

            // Takes
            if (currentFiles.takes) {
                arquivos.push({ nome: '05_Takes_Prompts.txt', conteudo: currentFiles.takes });
            }

            // Fazer download de todos
            arquivos.forEach((arquivo, index) => {
                setTimeout(() => {
                    downloadFile(arquivo.nome, arquivo.conteudo);
                }, index * 200); // Delay de 200ms entre cada download
            });

            alert(`‚úÖ Baixando ${arquivos.length} arquivos...`);
        });

        // Bot√£o Download JSON
        document.getElementById('downloadJSON').addEventListener('click', () => {
            if (!currentFiles.hook || !currentFiles.topicos) {
                alert('‚ùå Gere um roteiro primeiro!');
                return;
            }

            // Criar objeto JSON com toda a documenta√ß√£o
            const documentacao = {
                metadata: {
                    timestamp: new Date().toISOString(),
                    generator: 'Gerador Profissional de Roteiros',
                    version: '1.0'
                },
                input: {
                    title: document.getElementById('title').value,
                    synopsis: document.getElementById('synopsis').value,
                    numTopics: parseInt(document.getElementById('numTopics').value),
                    totalChars: parseInt(document.getElementById('totalChars').value)
                },
                roteiro: {
                    estrutura: currentFiles.estrutura || null,
                    hook: currentFiles.hook || null,
                    topicos: currentFiles.topicos || [],
                    completo: currentFiles.hook && currentFiles.topicos ?
                        [currentFiles.hook, ...currentFiles.topicos].join('\n\n') : null
                },
                documentos: {
                    trilha: currentFiles.trilha || null,
                    personagens: currentFiles.personagens || null,
                    personagensObj: currentPersonagens || null,
                    takes: currentFiles.takes || null
                },
                blocos: currentBlocks.length > 0 ? currentBlocks.map((bloco, i) => ({
                    numero: i + 1,
                    texto: bloco,
                    caracteres: bloco.length
                })) : null,
                estatisticas: {
                    totalCaracteresRoteiro: (currentFiles.hook?.length || 0) +
                        (currentFiles.topicos?.reduce((sum, t) => sum + t.length, 0) || 0),
                    totalCaracteresDocumentos: (currentFiles.estrutura?.length || 0) +
                        (currentFiles.hook?.length || 0) +
                        (currentFiles.topicos?.reduce((sum, t) => sum + t.length, 0) || 0) +
                        (currentFiles.trilha?.length || 0) +
                        (currentFiles.personagens?.length || 0) +
                        (currentFiles.takes?.length || 0),
                    numeroBlocos: currentBlocks.length,
                    numeroTopicos: currentFiles.topicos?.length || 0,
                    numeroPersonagens: currentPersonagens ? Object.keys(currentPersonagens).length : 0
                }
            };

            // Converter para JSON formatado
            const jsonContent = JSON.stringify(documentacao, null, 2);
            downloadFile('documentacao_completa.json', jsonContent);
            alert('‚úÖ JSON baixado com toda a documenta√ß√£o!');
        });

        // ============================================
        // IMPORT DE BLOCOS E GERA√á√ÉO DE TAKES
        // ============================================

        const blocosFileInput = document.getElementById('blocosFileInput');
        const personagensFileInput = document.getElementById('personagensFileInput');
        const importBlocosBtn = document.getElementById('importBlocosBtn');
        const importStatus = document.getElementById('importStatus');
        const importStatusText = document.getElementById('importStatusText');
        const importProgressBar = document.getElementById('importProgressBar');
        const importProgressPercent = document.getElementById('importProgressPercent');
        let importedBlocks = [];
        let importedPersonagens = {};

        // Fun√ß√£o para atualizar barra de progresso do import
        function updateImportProgress(percent) {
            importProgressBar.style.width = percent + '%';
            importProgressPercent.textContent = Math.round(percent) + '%';
        }

        // Habilitar bot√£o quando arquivo for selecionado
        blocosFileInput.addEventListener('change', async (e) => {
            const file = e.target.files[0];
            if (!file) {
                importBlocosBtn.disabled = true;
                return;
            }

            try {
                const text = await file.text();
                // Parsear blocos do formato "BLOCO 1\n...\n\nBLOCO 2\n..."
                const blocosMatch = text.split(/BLOCO \d+\n/).filter(b => b.trim());

                if (blocosMatch.length === 0) {
                    alert('‚ùå Arquivo inv√°lido! N√£o foram encontrados blocos no formato "BLOCO 1"');
                    importBlocosBtn.disabled = true;
                    return;
                }

                importedBlocks = blocosMatch.map(b => b.trim());
                importBlocosBtn.disabled = false;
                importStatusText.textContent = `${importedBlocks.length} blocos carregados`;
                importStatus.style.display = 'block';
            } catch (error) {
                alert('‚ùå Erro ao ler arquivo: ' + error.message);
                importBlocosBtn.disabled = true;
            }
        });

        // Processar arquivo de personagens (opcional)
        personagensFileInput.addEventListener('change', async (e) => {
            const file = e.target.files[0];
            if (!file) {
                importedPersonagens = {};
                return;
            }

            try {
                const text = await file.text();
                // Parsear formato: "1. NOME\n\ndescri√ß√£o...\n\n2. OUTRO_NOME\n\n..."
                const matches = text.split(/\n\d+\.\s+/);

                importedPersonagens = {};
                for (const match of matches) {
                    const trimmed = match.trim();
                    if (!trimmed) continue;

                    // Primeira linha √© o nome, resto √© a descri√ß√£o
                    const lines = trimmed.split('\n');
                    const nome = lines[0].trim();
                    const descricao = lines.slice(1).join('\n').trim();

                    if (nome && descricao) {
                        importedPersonagens[nome] = descricao;
                    }
                }

                const numPersonagens = Object.keys(importedPersonagens).length;
                if (numPersonagens > 0) {
                    importStatusText.textContent = `${importedBlocks.length} blocos + ${numPersonagens} personagens carregados`;
                    console.log(`‚úÖ ${numPersonagens} personagens importados:`, Object.keys(importedPersonagens));
                } else {
                    alert('‚ö†Ô∏è Nenhum personagem encontrado no arquivo. Verifique o formato.');
                }
            } catch (error) {
                alert('‚ùå Erro ao ler personagens: ' + error.message);
                importedPersonagens = {};
            }
        });

        // Gerar takes a partir dos blocos importados
        importBlocosBtn.addEventListener('click', async () => {
            if (importedBlocks.length === 0) {
                alert('‚ùå Nenhum bloco importado!');
                return;
            }

            importBlocosBtn.disabled = true;
            const modelo = document.getElementById('modeloTakesImport').value;
            const language = document.getElementById('language').value;

            try {
                // Resetar barra de progresso
                updateImportProgress(0);
                importStatusText.textContent = 'Iniciando gera√ß√£o de takes...';

                const BLOCOS_POR_GRUPO = 40;
                const numGrupos = Math.ceil(importedBlocks.length / BLOCOS_POR_GRUPO);
                let todosTakes = [];

                for (let g = 0; g < numGrupos; g++) {
                    const inicio = g * BLOCOS_POR_GRUPO;
                    const fim = Math.min(inicio + BLOCOS_POR_GRUPO, importedBlocks.length);
                    const blocosGrupo = importedBlocks.slice(inicio, fim);

                    // Atualizar progresso (0% a 90% durante gera√ß√£o)
                    const progressoAtual = (g / numGrupos) * 90;
                    updateImportProgress(progressoAtual);
                    importStatusText.textContent = `Gerando takes ${inicio+1}-${fim} de ${importedBlocks.length} (grupo ${g+1}/${numGrupos})...`;

                    const takesRes = await fetch('/api/gerar-takes', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            blocos: blocosGrupo,
                            personagens: importedPersonagens, // Usa personagens importados (ou {} se n√£o houver)
                            modelo: modelo,
                            offset: inicio,
                            language
                        })
                    });

                    const takesData = await takesRes.json();
                    if (takesData.error) {
                        throw new Error(takesData.error);
                    }

                    todosTakes.push(takesData.takesCompleto);
                }

                // Finalizando
                updateImportProgress(95);
                importStatusText.textContent = 'Compilando takes...';

                const takesCompleto = todosTakes.join('\n\n');
                currentFiles.takes = takesCompleto;
                downloadFile('05_Takes_Prompts_Importados.txt', takesCompleto);

                // Completo!
                updateImportProgress(100);
                importStatusText.textContent = `‚úÖ ${importedBlocks.length} takes gerados e baixados!`;
                alert(`‚úÖ Takes gerados com sucesso!\n\nTotal: ${importedBlocks.length} takes\nArquivo: 05_Takes_Prompts_Importados.txt`);

            } catch (error) {
                updateImportProgress(0);
                importStatusText.textContent = '‚ùå Erro: ' + error.message;
                alert('‚ùå Erro ao gerar takes: ' + error.message);
            } finally {
                importBlocosBtn.disabled = false;
            }
        });

        // ============================================
        // FERRAMENTAS DE MANIPULA√á√ÉO
        // ============================================

        function getFullScript() {
            if (!currentFiles.hook || !currentFiles.topicos) {
                alert('‚ùå Gere um roteiro primeiro!');
                return null;
            }
            return [currentFiles.hook, ...currentFiles.topicos].join('\n\n');
        }

        function displayBlocks(blocks) {
            currentBlocks = blocks;
            let html = '';
            blocks.forEach((block, i) => {
                const chars = block.length;
                const words = block.split(/\s+/).filter(w => w.length > 0).length;
                html += `
                    <div style="margin-bottom: 15px; padding: 12px; background: #fafafa; border-left: 2px solid #000000; border-radius: 0;">
                        <div style="font-weight: 500; color: #000000; margin-bottom: 5px;">
                            Bloco ${i + 1} | ${chars} chars | ${words} palavras
                        </div>
                        <div style="white-space: pre-wrap; color: #333;">${block}</div>
                    </div>
                `;
            });
            blocksPreview.innerHTML = html;

            // Mostrar estat√≠sticas
            const totalChars = blocks.reduce((sum, b) => sum + b.length, 0);
            const totalWords = blocks.reduce((sum, b) => sum + b.split(/\s+/).filter(w => w.length > 0).length, 0);
            blocksInfo.style.display = 'block';
            blocksStats.innerHTML = `
                <div>üì¶ <strong>${blocks.length}</strong> blocos gerados</div>
                <div>üìä <strong>${totalChars}</strong> caracteres totais</div>
                <div>üìù <strong>${totalWords}</strong> palavras totais</div>
            `;
        }

        // Dividir por caracteres
        divideByCharsBtn.addEventListener('click', () => {
            const text = getFullScript();
            if (!text) return;

            const maxChars = parseInt(document.getElementById('blockChars').value) || 490;

            // Dividir texto em senten√ßas (por ponto final, exclama√ß√£o, interroga√ß√£o)
            const sentences = text.match(/[^.!?]+[.!?]+/g) || [text];
            const blocks = [];
            let currentBlock = '';

            for (const sentence of sentences) {
                const trimmed = sentence.trim();
                if (!trimmed) continue;

                // Se adicionar a senten√ßa ultrapassar o limite e j√° temos conte√∫do, criar novo bloco
                if (currentBlock.length + trimmed.length + 1 > maxChars && currentBlock.length > 0) {
                    blocks.push(currentBlock.trim());
                    currentBlock = trimmed;
                } else {
                    currentBlock += (currentBlock.length > 0 ? ' ' : '') + trimmed;
                }
            }

            // Adicionar √∫ltimo bloco se houver
            if (currentBlock.trim().length > 0) {
                blocks.push(currentBlock.trim());
            }

            displayBlocks(blocks);
        });

        // Dividir por palavras
        divideByWordsBtn.addEventListener('click', () => {
            const text = getFullScript();
            if (!text) return;

            const wordsPerBlock = parseInt(document.getElementById('blockWords').value) || 17;

            // Dividir texto em senten√ßas
            const sentences = text.match(/[^.!?]+[.!?]+/g) || [text];
            const blocks = [];
            let currentBlock = '';
            let currentWordCount = 0;

            for (const sentence of sentences) {
                const trimmed = sentence.trim();
                if (!trimmed) continue;

                const sentenceWords = trimmed.split(/\s+/).filter(w => w.length > 0).length;

                // Se adicionar a senten√ßa ultrapassar o limite e j√° temos palavras, criar novo bloco
                if (currentWordCount + sentenceWords > wordsPerBlock && currentWordCount > 0) {
                    blocks.push(currentBlock.trim());
                    currentBlock = trimmed;
                    currentWordCount = sentenceWords;
                } else {
                    currentBlock += (currentBlock.length > 0 ? ' ' : '') + trimmed;
                    currentWordCount += sentenceWords;
                }
            }

            // Adicionar √∫ltimo bloco se houver
            if (currentBlock.trim().length > 0) {
                blocks.push(currentBlock.trim());
            }

            displayBlocks(blocks);
        });

        // Exportar SRT
        exportSrtBtn.addEventListener('click', () => {
            if (currentBlocks.length === 0) {
                alert('‚ùå Divida o roteiro em blocos primeiro!');
                return;
            }

            const readingRate = parseInt(document.getElementById('readingRate').value) || 12;
            const pauseTime = PAUSE_TIME; // 0.9 segundos

            let srtContent = '';
            let currentTime = 0;

            currentBlocks.forEach((block, index) => {
                const text = block.trim();
                if (!text) return;

                // Calcular dura√ß√£o baseado no reading rate (caracteres por segundo)
                const duration = text.length / readingRate;
                const startTime = currentTime;
                const endTime = currentTime + duration;

                // Formatar timestamps no formato SRT (HH:MM:SS,mmm)
                const startTimestamp = formatSrtTimestamp(startTime);
                const endTimestamp = formatSrtTimestamp(endTime);

                // Adicionar entrada SRT
                srtContent += `${index + 1}\n`;
                srtContent += `${startTimestamp} --> ${endTimestamp}\n`;
                srtContent += `${text}\n\n`;

                // Avan√ßar tempo (adicionar pausa entre blocos)
                currentTime = endTime + pauseTime;
            });

            // Download do arquivo SRT
            const blob = new Blob([srtContent.trim()], { type: 'text/srt;charset=utf-8' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'roteiro.srt';
            a.click();
            URL.revokeObjectURL(url);

            // Tamb√©m exportar documento de blocos (sem timestamps)
            let blocosContent = '';
            currentBlocks.forEach((block, index) => {
                const text = block.trim();
                if (!text) return;
                blocosContent += `${index + 1}. ${text}\n\n`;
            });

            // Download do arquivo de blocos
            const blocosBlob = new Blob([blocosContent.trim()], { type: 'text/plain;charset=utf-8' });
            const blocosUrl = URL.createObjectURL(blocosBlob);
            const blocosA = document.createElement('a');
            blocosA.href = blocosUrl;
            blocosA.download = 'blocos.txt';
            blocosA.click();
            URL.revokeObjectURL(blocosUrl);

            alert(`‚úÖ Arquivos gerados com ${currentBlocks.length} blocos!\nüìÑ roteiro.srt (com timestamps)\nüìÑ blocos.txt (sem timestamps)`);
        });

        // Formatar timestamp no formato SRT (HH:MM:SS,mmm)
        function formatSrtTimestamp(totalSeconds) {
            const hours = Math.floor(totalSeconds / 3600);
            const minutes = Math.floor((totalSeconds % 3600) / 60);
            const seconds = Math.floor(totalSeconds % 60);
            const milliseconds = Math.floor((totalSeconds % 1) * 1000);

            return `${pad2(hours)}:${pad2(minutes)}:${pad2(seconds)},${pad3(milliseconds)}`;
        }

        function pad2(n) {
            return String(n).padStart(2, '0');
        }

        function pad3(n) {
            return String(n).padStart(3, '0');
        }

        // ============================================
        // FERRAMENTAS DE IA
        // ============================================

        function showAiStatus(message) {
            aiStatus.style.display = 'block';
            aiStatusText.textContent = message;
        }

        function hideAiStatus() {
            aiStatus.style.display = 'none';
        }

        // Gerar Trilha Sonora
        gerarTrilhaBtn.addEventListener('click', async () => {
            const roteiro = getFullScript();
            if (!roteiro) return;

            gerarTrilhaBtn.disabled = true;
            showAiStatus('Gerando trilha sonora... Aguarde ~10 segundos');

            try {
                const modelo = modeloDocumentos.value;
                const language = document.getElementById('language').value;
                const response = await fetch('/api/gerar-trilha', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ roteiro, modelo, language })
                });

                const data = await response.json();

                if (data.error) {
                    alert(`‚ùå Erro: ${data.error}`);
                } else {
                    currentFiles.trilha = data.trilha;
                    downloadFile('02_Trilha_Sonora.txt', data.trilha);
                    showAiStatus(`‚úÖ Trilha sonora gerada! Custo: ~$${data.custoEstimado}`);
                    setTimeout(hideAiStatus, 5000);
                }
            } catch (error) {
                alert(`‚ùå Erro: ${error.message}`);
                hideAiStatus();
            }

            gerarTrilhaBtn.disabled = false;
        });

        // Gerar Personagens
        gerarPersonagensBtn.addEventListener('click', async () => {
            const roteiro = getFullScript();
            if (!roteiro) return;

            gerarPersonagensBtn.disabled = true;
            showAiStatus('Gerando descri√ß√µes de personagens... Aguarde ~15 segundos');

            try {
                const modelo = modeloDocumentos.value;
                const response = await fetch('/api/gerar-personagens', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ roteiro, modelo })
                });

                const data = await response.json();

                if (data.error) {
                    alert(`‚ùå Erro: ${data.error}`);
                } else {
                    currentFiles.personagens = data.personagensTexto;
                    currentPersonagens = data.personagensObj;

                    // Habilitar bot√£o de takes
                    gerarTakesBtn.disabled = false;
                    gerarTakesBtn.title = 'Gerar prompts de imagem para cada bloco';

                    downloadFile('04_Personagens_Descricoes.txt', data.personagensTexto);
                    showAiStatus(`‚úÖ ${data.numPersonagens} personagens gerados! Custo: ~$${data.custoEstimado}`);
                    setTimeout(hideAiStatus, 5000);
                }
            } catch (error) {
                alert(`‚ùå Erro: ${error.message}`);
                hideAiStatus();
            }

            gerarPersonagensBtn.disabled = false;
        });

        // Gerar Takes
        gerarTakesBtn.addEventListener('click', async () => {
            // Se n√£o tiver blocos, dividir automaticamente
            if (currentBlocks.length === 0) {
                const roteiro = getFullScript();
                if (!roteiro) return;

                showAiStatus('Dividindo roteiro em blocos automaticamente...');
                await dividirBlocosAutomaticamente(roteiro);
            }

            if (!currentPersonagens) {
                alert('‚ùå Gere os personagens primeiro!');
                return;
            }

            gerarTakesBtn.disabled = true;
            showAiStatus(`Gerando ${currentBlocks.length} takes... Aguarde ~20 segundos`);

            try {
                const modelo = modeloDocumentos.value;
                const response = await fetch('/api/gerar-takes', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        blocos: currentBlocks,
                        personagens: currentPersonagens,
                        modelo
                    })
                });

                const data = await response.json();

                if (data.error) {
                    alert(`‚ùå Erro: ${data.error}`);
                } else {
                    currentFiles.takes = data.takesCompleto;
                    downloadFile('05_Takes_Prompts.txt', data.takesCompleto);
                    showAiStatus(`‚úÖ ${data.numTakes} takes gerados! Custo: ~$${data.custoEstimado}`);
                    setTimeout(hideAiStatus, 5000);
                }
            } catch (error) {
                alert(`‚ùå Erro: ${error.message}`);
                hideAiStatus();
            }

            gerarTakesBtn.disabled = false;
        });

        // ============================================
        // MODO AUTOM√ÅTICO
        // ============================================

        // Toggle do bot√£o autom√°tico
        modoAutomatico.addEventListener('change', () => {
            btnAutomaticoContainer.style.display = modoAutomatico.checked ? 'block' : 'none';
        });

        // Fun√ß√£o para dividir blocos automaticamente
        async function dividirBlocosAutomaticamente(texto) {
            const maxChars = parseInt(document.getElementById('blockCharsConfig').value) || 490;

            const sentences = texto.match(/[^.!?]+[.!?]+/g) || [texto];
            const blocks = [];
            let currentBlock = '';

            for (const sentence of sentences) {
                const trimmed = sentence.trim();
                if (!trimmed) continue;

                if (currentBlock.length + trimmed.length + 1 > maxChars && currentBlock.length > 0) {
                    blocks.push(currentBlock.trim());
                    currentBlock = trimmed;
                } else {
                    currentBlock += (currentBlock.length > 0 ? ' ' : '') + trimmed;
                }
            }

            if (currentBlock.trim().length > 0) {
                blocks.push(currentBlock.trim());
            }

            displayBlocks(blocks);
            return blocks;
        }

        // Fun√ß√£o para gerar documentos automaticamente (chamada ap√≥s gerar roteiro)
        async function gerarDocumentosAutomaticamente() {
            const roteiro = getFullScript();
            if (!roteiro) return;

            const modelo = modeloDocumentosInicio.value;
            const modeloTakes = modeloTakesInicio.value;
            const tituloArquivo = getTituloArquivo(); // Nome base dos arquivos

            try {
                // PASSO 1: Dividir em blocos
                updateProgress(70, 'üìê Dividindo roteiro em blocos...');
                addMessage('Sistema', '[üìê 1/5] Dividindo roteiro em blocos...', 'system');
                await dividirBlocosAutomaticamente(roteiro);

                // Download blocos.txt
                const blocosTexto = currentBlocks.map((bloco, i) => `BLOCO ${i + 1}\n${bloco}`).join('\n\n');
                currentFiles.blocos = blocosTexto;
                currentDocs.blocos = blocosTexto;
                downloadFile(`${tituloArquivo}_blocos.txt`, blocosTexto);

                await new Promise(resolve => setTimeout(resolve, 500));

                // PASSO 2: Gerar Trilha
                updateProgress(75, 'üéµ Gerando trilha sonora...');
                addMessage('Sistema', '[üéµ 2/5] Gerando trilha sonora... (~10s)', 'system');
                const language = document.getElementById('language').value;
                const trilhaRes = await fetch('/api/gerar-trilha', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ roteiro, modelo, language })
                });
                const trilhaData = await trilhaRes.json();
                if (trilhaData.error) throw new Error(trilhaData.error);
                currentFiles.trilha = trilhaData.trilha;
                currentDocs.trilha = trilhaData.trilha;

                // Mostrar conte√∫do gerado
                addMessage('üéµ Trilha Sonora', trilhaData.trilha, 'assistant', {
                    charCount: trilhaData.trilha.length,
                    charCountNoSpaces: trilhaData.trilha.replace(/\s/g, '').length,
                    wordCount: trilhaData.trilha.split(/\s+/).filter(w => w.length > 0).length
                });

                downloadFile(`${tituloArquivo}_trilha_sonora.txt`, trilhaData.trilha);
                addMessage('Sistema', `‚úÖ Trilha sonora gerada! (~$${trilhaData.custoEstimado})`, 'system');
                updateCharCounters();

                // PASSO 3: Gerar Personagens
                updateProgress(80, 'üë• Gerando personagens...');
                addMessage('Sistema', '[üë• 3/5] Gerando personagens... (~15s)', 'system');
                const persRes = await fetch('/api/gerar-personagens', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ roteiro, modelo, language })
                });
                const persData = await persRes.json();
                if (persData.error) throw new Error(persData.error);
                currentFiles.personagens = persData.personagensTexto;
                currentDocs.personagens = persData.personagensTexto;
                currentPersonagens = persData.personagensObj;

                // Mostrar conte√∫do gerado
                addMessage('üë• Personagens', persData.personagensTexto, 'assistant', {
                    charCount: persData.personagensTexto.length,
                    charCountNoSpaces: persData.personagensTexto.replace(/\s/g, '').length,
                    wordCount: persData.personagensTexto.split(/\s+/).filter(w => w.length > 0).length
                });

                downloadFile(`${tituloArquivo}_personagens.txt`, persData.personagensTexto);
                addMessage('Sistema', `‚úÖ ${persData.numPersonagens} personagens gerados! (~$${persData.custoEstimado})`, 'system');

                // Habilitar bot√£o de takes manual
                gerarTakesBtn.disabled = false;
                gerarTakesBtn.title = 'Gerar prompts de imagem para cada bloco';

                updateCharCounters();

                // PASSO 4: Gerar SRT
                updateProgress(85, 'üìÑ Gerando SRT...');
                addMessage('Sistema', '[üìÑ 4/5] Gerando SRT... (~2s)', 'system');
                const readingRate = parseInt(document.getElementById('readingRateConfig').value) || 12;
                const pauseTime = 0.9;
                let srtContent = '';
                let currentTime = 0;
                currentBlocks.forEach((block, index) => {
                    const text = block.trim();
                    if (!text) return;
                    const duration = text.length / readingRate;
                    const startTime = currentTime;
                    const endTime = currentTime + duration;
                    srtContent += `${index + 1}\n${formatSrtTimestamp(startTime)} --> ${formatSrtTimestamp(endTime)}\n${text}\n\n`;
                    currentTime = endTime + pauseTime;
                });
                currentFiles.srt = srtContent.trim();
                currentDocs.srt = srtContent.trim();
                downloadFile(`${tituloArquivo}.srt`, srtContent.trim());
                addMessage('Sistema', `‚úÖ SRT gerado com ${currentBlocks.length} blocos!`, 'system');

                // PASSO 5: Gerar Takes (em grupos de 40 - otimizado custo vs seguran√ßa)
                const BLOCOS_POR_GRUPO = 40;
                const numGrupos = Math.ceil(currentBlocks.length / BLOCOS_POR_GRUPO);
                let todosTakes = [];
                let ultimoCustoTakes = '0.025';

                console.log(`üé¨ Starting takes generation: ${currentBlocks.length} blocks, ${numGrupos} groups`);
                addMessage('Sistema', `üé¨ Iniciando gera√ß√£o de ${currentBlocks.length} takes em ${numGrupos} grupo(s)...`, 'system');

                for (let g = 0; g < numGrupos; g++) {
                    try {
                        const inicio = g * BLOCOS_POR_GRUPO;
                        const fim = Math.min(inicio + BLOCOS_POR_GRUPO, currentBlocks.length);
                        const blocosGrupo = currentBlocks.slice(inicio, fim);

                        console.log(`üì¶ Processing group ${g+1}/${numGrupos}: blocks ${inicio+1}-${fim} (${blocosGrupo.length} blocks)`);

                        // Atualizar progresso: 85% a 100% distribu√≠do entre os grupos
                        const progressoParcial = 85 + ((g + 1) / numGrupos) * 15;
                        updateProgress(Math.round(progressoParcial), `üé¨ Takes: Grupo ${g+1}/${numGrupos}`);
                        addMessage('Sistema', `[üé¨ 5/5 - Grupo ${g+1}/${numGrupos}] Gerando takes ${inicio+1}-${fim} (${blocosGrupo.length} blocos)... (~20s)`, 'system');

                        const takesRes = await fetch('/api/gerar-takes', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({
                                blocos: blocosGrupo,
                                personagens: currentPersonagens,
                                modelo: modeloTakes,
                                offset: inicio,
                                language
                            })
                        });

                        console.log(`üì° Response status for group ${g+1}: ${takesRes.status}`);

                        if (!takesRes.ok) {
                            const errorText = await takesRes.text();
                            console.error(`‚ùå HTTP error in group ${g+1}:`, errorText);
                            addMessage('Erro', `‚ùå Erro HTTP no grupo ${g+1}/${numGrupos}: ${takesRes.status}`, 'error');
                            throw new Error(`HTTP ${takesRes.status}: ${errorText}`);
                        }

                        const takesData = await takesRes.json();
                        console.log(`‚úÖ Group ${g+1} data received:`, takesData.numTakes, 'takes');

                        if (takesData.error) {
                            console.error(`‚ùå API error in group ${g+1}:`, takesData.error);
                            addMessage('Erro', `‚ùå Erro no grupo ${g+1}/${numGrupos}: ${takesData.error}`, 'error');
                            throw new Error(takesData.error);
                        }

                        // Mostrar preview dos takes gerados (primeiros 500 chars)
                        const preview = takesData.takesCompleto.substring(0, 500) + '...';
                        addMessage(`üé¨ Takes ${inicio+1}-${fim}`, preview, 'assistant', {
                            charCount: takesData.takesCompleto.length
                        });

                        todosTakes.push(takesData.takesCompleto);
                        ultimoCustoTakes = takesData.custoEstimado;
                        addMessage('Sistema', `‚úÖ Takes ${inicio+1}-${fim} gerados! (${takesData.numTakes} takes, ${takesData.takesCompleto.length} caracteres)`, 'system');
                        console.log(`‚úÖ Group ${g+1}/${numGrupos} completed successfully`);
                        updateCharCounters();

                    } catch (groupError) {
                        console.error(`‚ùå Fatal error in group ${g+1}/${numGrupos}:`, groupError);
                        addMessage('Erro', `‚ùå Erro fatal no grupo ${g+1}/${numGrupos}: ${groupError.message}. Interrompendo gera√ß√£o de takes.`, 'error');
                        throw groupError; // Re-throw to stop the automatic mode
                    }
                }

                console.log(`‚úÖ All ${numGrupos} groups completed! Total takes: ${todosTakes.length} files`);

                const takesCompleto = todosTakes.join('\n\n');
                currentFiles.takes = takesCompleto;
                currentDocs.takes = takesCompleto;
                downloadFile(`${tituloArquivo}_takes.txt`, takesCompleto);
                addMessage('Sistema', `‚úÖ TAKES COMPLETOS: ${currentBlocks.length} takes gerados em ${numGrupos} grupo(s)!`, 'system');
                addMessage('Sistema', `üì• Arquivo "${tituloArquivo}_takes.txt" baixado automaticamente!`, 'system');

                // Sucesso!
                updateProgress(100, '‚úÖ COMPLETO!');

                // Calcular tempo total
                const tempoTotalMs = Date.now() - startTimeTotal;
                const minutos = Math.floor(tempoTotalMs / 60000);
                const segundos = Math.floor((tempoTotalMs % 60000) / 1000);
                const tempoFormatado = `${minutos}:${segundos.toString().padStart(2, '0')}`;

                const custoTotal = (parseFloat(trilhaData.custoEstimado) +
                                   parseFloat(persData.custoEstimado) +
                                   (parseFloat(ultimoCustoTakes) * numGrupos)).toFixed(3);
                addMessage('Sistema', `üí∞ Custo dos documentos: ~$${custoTotal}`, 'system');
                addMessage('Sistema', `‚è±Ô∏è TEMPO TOTAL DE GERA√á√ÉO: ${tempoFormatado}`, 'system');
                addMessage('Sistema', `üéâ GERA√á√ÉO AUTOM√ÅTICA FINALIZADA COM SUCESSO!`, 'system');
                addMessage('Sistema', `üì¶ Todos os 5 arquivos foram baixados: Trilha Sonora, Personagens, SRT, Blocos e Takes!`, 'system');

            } catch (error) {
                console.error('‚ùå Fatal error in automatic mode:', error);
                addMessage('Erro', `‚ùå Erro ao gerar documentos: ${error.message}`, 'error');
                addMessage('Sistema', `‚ö†Ô∏è Verifique o console (F12) para mais detalhes do erro.`, 'system');
                updateProgress(0, '‚ùå Erro na gera√ß√£o');
            }
        }

        // Event Listeners para Bot√µes de Download
        document.getElementById('downloadTudo').addEventListener('click', () => {
            if (!currentFiles) {
                alert('Nenhum documento gerado ainda!');
                return;
            }

            // Criar ZIP com todos os arquivos
            const zip = new JSZip();

            if (currentFiles.estrutura) zip.file('00_Estrutura.txt', currentFiles.estrutura);
            if (currentFiles.hook) zip.file('01_Hook.txt', currentFiles.hook);
            if (currentFiles.topico1) zip.file('02_Topico1.txt', currentFiles.topico1);
            if (currentFiles.topico2) zip.file('03_Topico2.txt', currentFiles.topico2);
            if (currentFiles.topico3) zip.file('04_Topico3.txt', currentFiles.topico3);
            if (currentFiles.conclusao) zip.file('05_Conclusao.txt', currentFiles.conclusao);
            if (currentFiles.trilha) zip.file('06_Trilha_Sonora.txt', currentFiles.trilha);
            if (currentFiles.personagens) zip.file('07_Personagens.txt', currentFiles.personagens);
            if (currentFiles.textoNarrado) zip.file('08_Texto_Narrado.txt', currentFiles.textoNarrado);
            if (currentFiles.titulo) zip.file('09_Titulo_Descricao.txt', currentFiles.titulo);

            // Roteiro completo
            const roteiroCompleto = getFullScript();
            if (roteiroCompleto) zip.file('00_Roteiro_Completo.txt', roteiroCompleto);

            // Gerar e baixar ZIP
            zip.generateAsync({type: 'blob'}).then(function(content) {
                const a = document.createElement('a');
                a.href = URL.createObjectURL(content);
                a.download = `roteiro_${new Date().toISOString().slice(0,10)}.zip`;
                a.click();
            });
        });

        document.getElementById('downloadJSON').addEventListener('click', () => {
            if (!currentFiles) {
                alert('Nenhum documento gerado ainda!');
                return;
            }

            const jsonData = {
                gerado_em: new Date().toISOString(),
                titulo: document.getElementById('title').value,
                arquivos: currentFiles
            };

            downloadFile('documentacao_completa.json', JSON.stringify(jsonData, null, 2));
        });

        document.getElementById('downloadCompleto').addEventListener('click', () => {
            const roteiroCompleto = getFullScript();
            if (roteiroCompleto) {
                downloadFile('00_Roteiro_Completo.txt', roteiroCompleto);
            }
        });

        // Gerar Todos os Documentos (Modo Autom√°tico)
        gerarTodosBtn.addEventListener('click', async () => {
            const roteiro = getFullScript();
            if (!roteiro) return;

            const modelo = modeloDocumentos.value;

            // Desabilitar todos os bot√µes
            gerarTodosBtn.disabled = true;
            gerarTrilhaBtn.disabled = true;
            gerarPersonagensBtn.disabled = true;
            gerarTakesBtn.disabled = true;

            try {
                // PASSO 1: Dividir em blocos
                showAiStatus('[1/4] Dividindo roteiro em blocos...');
                await dividirBlocosAutomaticamente(roteiro);
                await new Promise(resolve => setTimeout(resolve, 500));

                // PASSO 2: Gerar Trilha
                showAiStatus('[2/4] Gerando trilha sonora... (~10s)');
                const language = document.getElementById('language').value;
                const trilhaRes = await fetch('/api/gerar-trilha', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ roteiro, modelo, language })
                });
                const trilhaData = await trilhaRes.json();
                if (trilhaData.error) throw new Error(trilhaData.error);
                currentFiles.trilha = trilhaData.trilha;
                downloadFile('02_Trilha_Sonora.txt', trilhaData.trilha);

                // PASSO 3: Gerar Personagens
                showAiStatus('[3/4] Gerando personagens... (~15s)');
                const persRes = await fetch('/api/gerar-personagens', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ roteiro, modelo, language })
                });
                const persData = await persRes.json();
                if (persData.error) throw new Error(persData.error);
                currentFiles.personagens = persData.personagensTexto;
                currentPersonagens = persData.personagensObj;
                downloadFile('04_Personagens_Descricoes.txt', persData.personagensTexto);

                // PASSO 4: Gerar Takes
                showAiStatus('[4/4] Gerando takes... (~20s)');
                const takesRes = await fetch('/api/gerar-takes', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        blocos: currentBlocks,
                        personagens: currentPersonagens,
                        modelo,
                        language
                    })
                });
                const takesData = await takesRes.json();
                if (takesData.error) throw new Error(takesData.error);
                currentFiles.takes = takesData.takesCompleto;
                downloadFile('05_Takes_Prompts.txt', takesData.takesCompleto);

                // Sucesso!
                const custoTotal = (parseFloat(trilhaData.custoEstimado) +
                                   parseFloat(persData.custoEstimado) +
                                   parseFloat(takesData.custoEstimado)).toFixed(3);
                showAiStatus(`‚úÖ Todos os documentos gerados! Custo total: ~$${custoTotal}`);
                setTimeout(hideAiStatus, 7000);

                // Habilitar bot√£o de takes
                gerarTakesBtn.disabled = false;
                gerarTakesBtn.title = 'Gerar prompts de imagem para cada bloco';

            } catch (error) {
                alert(`‚ùå Erro: ${error.message}`);
                hideAiStatus();
            }

            // Reabilitar bot√µes
            gerarTodosBtn.disabled = false;
            gerarTrilhaBtn.disabled = false;
            gerarPersonagensBtn.disabled = false;
        });
    </script>
</body>
</html>
